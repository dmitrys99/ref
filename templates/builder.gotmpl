// Code generated by go-swagger; DO NOT EDIT.


{{ if .Copyright -}}// {{ comment .Copyright -}}{{ end }}


package {{.Package}}
{{ $package := .Package }}


// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (

	"strings"
	"net/http"

	"github.com/go-openapi/swag"
	spec "github.com/go-openapi/spec"
	context "golang.org/x/net/context"
	loads "github.com/go-openapi/loads"
	errors "github.com/go-openapi/errors"
	strfmt "github.com/go-openapi/strfmt"
	runtime "github.com/go-openapi/runtime"
	middleware "github.com/go-openapi/runtime/middleware"
	security "github.com/go-openapi/runtime/security"

	{{ range .DefaultImports }}{{ printf "%q" . }}
	{{ end }}
	{{ range $key, $value := .Imports }}{{ $key }} {{ printf "%q" $value }}
	{{ end }}
)

// New{{ pascalize .Name }}API creates a new {{ pascalize .Name }} instance
func New{{ pascalize .Name }}API(spec *loads.Document) *{{ pascalize .Name }}API {
	return &{{ pascalize .Name }}API{
		spec:                   spec,
		{{range .Operations}}{{if ne .Package $package}}{{ pascalize .Package }}{{end}}{{ pascalize .Name }}Handler: {{if ne .Package $package}}{{ .Package }}.{{end}}{{ pascalize .Name }}HandlerFunc(func({{ if .WithContext }}ctx context.Context, {{ end }}params {{if ne .Package $package}}{{ .Package }}.{{end}}{{ pascalize .Name }}Params{{if .Authorized}}, principal {{if not ( eq .Principal "interface{}" )}}*{{ end }}{{.Principal}}{{end}}) middleware.Responder {
			return middleware.NotImplemented("operation {{if ne .Package $package}}{{ pascalize .Package }}{{end}}{{pascalize .Name}} has not yet been implemented")
		}),
		{{end}}
	}
}

/*{{ pascalize .Name }}API {{ if .Info }}{{ if .Info.Description }}{{.Info.Description}}{{ else }}the {{ humanize .Name }} API{{ end }}{{ end }} */
type {{ pascalize .Name }}API struct {

	{{range .Operations}}// {{if ne .Package $package}}{{ pascalize .Package }}{{end}}{{ pascalize .Name }}Handler sets the operation handler for the {{ humanize .Name }} operation
	{{if ne .Package $package}}{{ pascalize .Package }}{{end}}{{ pascalize .Name }}Handler {{if ne .Package $package}}{{.Package}}.{{end}}{{ pascalize .Name }}Handler
	{{end}}

}

func ({{.ReceiverName}} *{{ pascalize .Name }}API) GetAllRoutes() *mux.Router {
	r := mux.NewRouter()

{{if .Operations}}
	{{range .Operations}}
	r.Handle({{ printf "%q" (cleanPath .Path) }}, New{{ pascalize .Name }}()){{- if not (eq (upper .Method) "GET") }}.Methods({{ printf "%q" (upper .Method) }}){{end -}}
	{{end}}{{end}}
	return r
}

func ({{.ReceiverName}} *{{ pascalize .Name }}API) initHandlerCache() {

{{if .Operations}}


	{{range .Operations}}
	if {{ .ReceiverName }}.handlers[{{ printf "%q" (upper .Method) }}] == nil {
		{{ .ReceiverName }}.handlers[{{ printf "%q" (upper .Method) }}] = make(map[string]http.Handler)
	}
	{{.ReceiverName}}.handlers[{{ printf "%q" (upper .Method) }}][{{ if eq .Path "/" }}""{{ else }}{{ printf "%q" (cleanPath .Path) }}{{ end }}] = {{if ne .Package $package}}{{.Package}}.{{end}}New{{ pascalize .Name }}({{.ReceiverName}}.context, {{.ReceiverName}}.{{if ne .Package $package}}{{ pascalize .Package }}{{end}}{{ pascalize .Name }}Handler)
	{{end}}
	{{end}}
}

// Serve creates a http handler to serve the API over HTTP
// can be used directly in http.ListenAndServe(":8000", api.Serve(nil))
func ({{.ReceiverName}} *{{ pascalize .Name }}API) Serve(builder middleware.Builder) http.Handler {
{{ .ReceiverName }}.Init()

if {{ .ReceiverName}}.Middleware != nil {
	return {{ .ReceiverName }}.Middleware(builder)
}
return {{.ReceiverName}}.context.APIHandler(builder)
}

// Init allows you to just initialize the handler cache, you can then recompose the middleware as you see fit
func ({{.ReceiverName}} *{{ pascalize .Name }}API) Init() {
if len({{.ReceiverName}}.handlers) == 0 {
	{{.ReceiverName}}.initHandlerCache()
}
}

// RegisterConsumer allows you to add (or override) a consumer for a media type.
func ({{.ReceiverName}} *{{ pascalize .Name }}API) RegisterConsumer(mediaType string, consumer runtime.Consumer) {
{{.ReceiverName}}.customConsumers[mediaType] = consumer
}

// RegisterProducer allows you to add (or override) a producer for a media type.
func ({{.ReceiverName}} *{{ pascalize .Name }}API) RegisterProducer(mediaType string, producer runtime.Producer) {
{{.ReceiverName}}.customProducers[mediaType] = producer
}
