// Code generated by go-swagger; DO NOT EDIT.

package {{.Package}}
{{ $package := .Package }}


// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (

	"strings"
	"net/http"

	{{ range .DefaultImports }}{{ printf "%q" . }}
	{{ end }}
	{{ range $key, $value := .Imports }}{{ $key }} {{ printf "%q" $value }}
	{{ end }}
)

// New{{ pascalize .Name }}API creates a new {{ pascalize .Name }} instance
func New{{ pascalize .Name }}API() *{{ pascalize .Name }}API {
	return &{{ pascalize .Name }}API{
		{{range .Operations}}{{if ne .Package $package}}{{ pascalize .Package }}{{end}}{{ pascalize .Name }}Handler: {{if ne .Package $package}}{{ .Package }}.{{end}}{{ pascalize .Name }}HandlerFunc(func({{ if .WithContext }}ctx context.Context, {{ end }}params {{if ne .Package $package}}{{ .Package }}.{{end}}{{ pascalize .Name }}Params{{if .Authorized}}, principal {{if not ( eq .Principal "interface{}" )}}*{{ end }}{{.Principal}}{{end}}) ResponderWriter {
			return nil
			//middleware.NotImplemented("operation {{if ne .Package $package}}{{ pascalize .Package }}{{end}}{{pascalize .Name}} has not yet been implemented")
		}),
		{{end}}
	}
}

/*{{ pascalize .Name }}API {{ if .Info }}{{ if .Info.Description }}{{.Info.Description}}{{ else }}the {{ humanize .Name }} API{{ end }}{{ end }} */
type {{ pascalize .Name }}API struct {

	{{range .Operations}}// {{if ne .Package $package}}{{ pascalize .Package }}{{end}}{{ pascalize .Name }}Handler sets the operation handler for the {{ humanize .Name }} operation
	{{if ne .Package $package}}{{ pascalize .Package }}{{end}}{{ pascalize .Name }}Handler {{if ne .Package $package}}{{.Package}}.{{end}}{{ pascalize .Name }}Handler
	{{end}}

}

func ({{.ReceiverName}} *{{ pascalize .Name }}API) GetAllRoutes() *mux.Router {
	r := mux.NewRouter()

	{{if .Operations}}
	{{range .Operations}}
	r.Handle({{ printf "%q" (cleanPath .Path) }}, {{if ne .Package $package}}{{.Package}}.{{end}}New{{ pascalize .Name }}()){{- if ne (upper .Method) "GET" }}.Methods({{ printf "%q" (upper .Method) }}){{end -}}
	{{end}}{{end}}
	return r
}
{{/*
func ({{.ReceiverName}} *{{ pascalize .Name }}API) initHandlerCache() {

{{if .Operations}}


	{{range .Operations}}
	if {{ .ReceiverName }}.handlers[{{ printf "%q" (upper .Method) }}] == nil {
		{{ .ReceiverName }}.handlers[{{ printf "%q" (upper .Method) }}] = make(map[string]http.Handler)
	}
	{{.ReceiverName}}.handlers[{{ printf "%q" (upper .Method) }}][{{ if eq .Path "/" }}""{{ else }}{{ printf "%q" (cleanPath .Path) }}{{ end }}] = {{if ne .Package $package}}{{.Package}}.{{end}}New{{ pascalize .Name }}({{.ReceiverName}}.context, {{.ReceiverName}}.{{if ne .Package $package}}{{ pascalize .Package }}{{end}}{{ pascalize .Name }}Handler)
	{{end}}
	{{end}}
}
*/}}
// Serve creates a http handler to serve the API over HTTP
// can be used directly in http.ListenAndServe(":8000", api.Serve(nil))
func ({{.ReceiverName}} *{{ pascalize .Name }}API) Serve() http.Handler {
	{{ .ReceiverName }}.Init()

}

// Init allows you to just initialize the handler cache, you can then recompose the middleware as you see fit
func ({{.ReceiverName}} *{{ pascalize .Name }}API) Init() {
     	{{.ReceiverName}}.initHandlerCache()
}

